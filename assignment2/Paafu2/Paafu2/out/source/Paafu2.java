/* autogenerated by Processing revision 1286 on 2023-02-04 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Collections;
import java.lang.Math;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Paafu2 extends PApplet {

/* CSci-5609 Assignment 2: Visualization of Paafu Kinship Ties for the Islands of Micronesia
*/

// === GLOBAL DATA VARIABLES ===

// Raw data tables & objects
Table locationTable;
Table populationTable;
PaafuDirections paafuDirections;

// Derived data: kinships based on Paafu directions
KinshipTies kinshipTies;

// Derived data: mins and maxes for each data variable
float minLatitude, maxLatitude;
float minLongitude, maxLongitude;
float minPop1980, maxPop1980;
float minPop1994, maxPop1994;
float minPop2000, maxPop2000;
float minPop2010, maxPop2010;
float minArea, maxArea;

// Graphics and UI variables
PanZoomMap panZoomMap;
PFont labelFont;
String highlightedMunicipality = "";
String selectedMunicipality = "Romanum";
String highlightedDirection = "";

float mapX1, mapY1, mapX2, mapY2;

// === PROCESSING BUILT-IN FUNCTIONS ===

 public void setup() {
  // size of the graphics window
  /* size commented out by preprocessor */;

  // load data in from disk
  loadRawDataTables();
  paafuDirections = new PaafuDirections();

  // compute derived data
  // combine the location and direction data to identify Paafu-style kinship ties
  kinshipTies = new KinshipTies(paafuDirections, locationTable);

  // do any other data processing, e.g., finding mins and maxes for data variables
  computeDerivedData();
  
  // these coordinates define a rectangular region for the map that happens to be
  // centered around Micronesia
  panZoomMap = new PanZoomMap(5.2f, 138, 10.0f, 163.1f);
  
  // these initial values provide a good view of Chuuk Lagoon, but you can
  // comment these out to start with all of the data on the screen
  panZoomMap.scale = 87430.2f;
  panZoomMap.translateX = -47255.832f;
  panZoomMap.translateY = -43944.914f;
  
  labelFont = loadFont("Futura-Medium-18.vlw");
}

 public void draw_pie_slice(float angle, float origx, float origy)
{
  PVector island = new PVector(origx, origy);

  /* define lines */
  float minus_angle = angle - 5.5f;
  float plus_angle = angle + 5.5f;
  if (angle == 180.0f)
    plus_angle = -175.0f;

  PVector minus_vector = new PVector(0, -1);
  PVector plus_vector = new PVector(0, -1);

  minus_vector.rotate(radians(minus_angle));
  plus_vector.rotate(radians(plus_angle));

  minus_vector.normalize();
  plus_vector.normalize();

  float dist = (width > height ? width : height) * 1000;

  PVector p1 = PVector.add(
    island, PVector.mult(
      minus_vector, dist
    )
  );

  PVector p2 = PVector.add(
    island, PVector.mult(
      plus_vector, dist
    )
  );
  
  /* edge1 and edge2 now contain the intersection points with the walls */
  fill(120);
  noStroke();
  triangle(island.x, island.y, p1.x, p1.y, p2.x, p2.y);
}

 public void draw_kinship()
{ 
  /* 
    Added ability to deselect municipalities 
    Romanum starts as selected though
    Dont draw anything if no municipality selected
  */
  if (selectedMunicipality != "")
  {
    /* get and draw kinship lines between islands */
    HashMap<String, ArrayList<String>> dirTies = 
          kinshipTies.getKinshipTies(selectedMunicipality);

    TableRow curr = locationTable.findRow(selectedMunicipality, "Municipality");
    float clat = curr.getFloat("Latitude");
    float clon = curr.getFloat("Longitude");

    float cx = panZoomMap.longitudeToScreenX(clon);
    float cy = panZoomMap.latitudeToScreenY(clat);

    float baseWeight = 0.01f;

    float mxlon = panZoomMap.screenXtoLongitude(mouseX);
    float mylat = panZoomMap.screenYtoLatitude(mouseY);

    String mouse_dir = paafuDirections.getDirectionFromTo(
      clat, clon, /* starting island */
      mylat, mxlon /* ending island */
    );

    highlightedDirection = mouse_dir;

    draw_pie_slice(paafuDirections.getAngle(mouse_dir), cx, cy);

    ArrayList<String> municipalities = dirTies.get(mouse_dir);
    /* define strokeWeight based on connections */
    float weight = baseWeight + 0.1f * municipalities.size();
    strokeWeight(weight);
    stroke(0, 20, 0);
    if (municipalities.size() > 0) {
      for (String m : municipalities) {
        TableRow row = locationTable.findRow(m, "Municipality");

        float lat = row.getFloat("Latitude");
        float lon = row.getFloat("Longitude");

        float x = panZoomMap.longitudeToScreenX(lon);
        float y = panZoomMap.latitudeToScreenY(lat);

        line(cx, cy, x, y);

        cx = x;
        cy = y;
      }
    }

    strokeWeight(1);
  }
}

 public void draw() {
  // clear the screen
  background(50);
  
  // Municipalities should highlight (i.e., change appearance in some way) whenever the mouse is hovering
  // over them so the user knows something will happen if they click.  If they do click while a municipality
  // is highlighted, then that municipality becomes the selectedMunicipality and the visualization should
  // update to show kinship relationships for it.
  highlightedMunicipality = getMunicipalityUnderMouse();
  
  
  // Example Solution to Assignment 1
     
  // defined in screen space, so the circles will be the same size regardless of zoom level
  float minRadius = 3;
  float maxRadius = 28;
  
  // color lowestPopulationColor = color(255, 224, 121);
  // color highestPopulationColor = color(232, 81, 21);

  int lowestPopulationColor = color(194, 240, 207);
  int highestPopulationColor = color(2, 48, 15);

  // draw the bounds of the map
  fill(100);
  stroke(0, 20, 0);
  strokeWeight(1);
  rectMode(CORNERS);
  mapX1 = panZoomMap.longitudeToScreenX(138.0f);
  mapY1 = panZoomMap.latitudeToScreenY(5.2f);
  mapX2 = panZoomMap.longitudeToScreenX(163.1f);
  mapY2 = panZoomMap.latitudeToScreenY(10.0f);
  rect(mapX1, mapY1, mapX2, mapY2);

  draw_kinship();

  /* for look purposes */
  fill(50);
  strokeWeight(1);
  rect(mapX1 - width*2, mapY2 - height*2, mapX2 + width*2, mapY2);
  rect(mapX2, mapY2 - height*2, mapX2 + width*2, mapY1 +height*2);
  rect(mapX1 - width*2, mapY1, mapX2 + width*2, mapY1 + height*2);
  rect(mapX1 - width*2, mapY1 + height*2, mapX1, mapY2 - height*2);
  noStroke();
  rect(mapX1 - width*2, mapY2 - height*2, mapX2 + width*2, mapY2-1);
  rect(mapX2+1, mapY2 - height*2, mapX2 + width*2, mapY1 +height*2);
  rect(mapX1 - width*2, mapY1+1, mapX2 + width*2, mapY1 + height*2);
  
  for (int i=0; i<locationTable.getRowCount(); i++) {
    TableRow rowData = locationTable.getRow(i);
    String municipalityName = rowData.getString("Municipality");
    float latitude = rowData.getFloat("Latitude");
    float longitude = rowData.getFloat("Longitude");
    float screenX = panZoomMap.longitudeToScreenX(longitude);
    float screenY = panZoomMap.latitudeToScreenY(latitude);
    
    // lat,long code above is the same as part A.  if we also get the municipality name
    // for this row in the location table, then we can look up population data for the
    // municipality in the population table
    TableRow popRow = populationTable.findRow(municipalityName, "Municipality");
    int pop2010 = popRow.getInt("Population 2010 Census");
    int area = popRow.getInt("Area");

    // normalize data values to a 0..1 range
    float pop2010_01 = (pop2010 - minPop2010) / (maxPop2010 - minPop2010);
    float area_01 = (area - minArea) / (maxArea - minArea);
    
    // two examples using lerp*() to map the data values to changes in visual attributes
    
    // 1. adjust the radius of the island in proportion to its area
    float radius = lerp(minRadius, maxRadius, area_01);
    
    // 2. adjust the fill color in proportion to the population
    int c = lerpColorLab(lowestPopulationColor, highestPopulationColor, pop2010_01);
    fill(c);

    if (municipalityName.equals(highlightedMunicipality))
    {
      strokeWeight(2);
      stroke(21, 77, 58);
    }
    else
    {
      noStroke();
    }

    ellipseMode(RADIUS);
    circle(screenX, screenY, radius);

    strokeWeight(1);
    
    textAlign(LEFT, CENTER);
    float xTextOffset = radius + 4; // move the text to the right of the circle
    fill(32, 255, 0);
    text(municipalityName, screenX + xTextOffset, screenY);
  }

  text(highlightedDirection, mouseX, mouseY - 10);
  
  // DRAW THE LEGEND
  
  // block off the right side of the screen with a big rect
  fill(250);
  stroke(111, 87, 0);
  rect(1400, -10, 1610, 910);

  // colormap legend
  fill(111, 87, 0);
  textAlign(CENTER, CENTER);
  text("2010 Population", 1500, 50);

  strokeWeight(1);
  textAlign(RIGHT, CENTER);
  int gradientHeight = 200;
  int gradientWidth = 40;
  int labelStep = gradientHeight / 5;
  for (int y=0; y<gradientHeight; y++) {
    float amt = 1.0f - (float)y/(gradientHeight-1);
    int c = lerpColorLab(lowestPopulationColor, highestPopulationColor, amt);
    stroke(c);
    line(1500, 70 + y, 1500+gradientWidth, 70 + y);
    if ((y % labelStep == 0) || (y == gradientHeight-1)) {
      int labelValue = (int)(minPop2010 + amt*(maxPop2010 - minPop2010));
      text(labelValue, 1490, 70 + y);
    }
  }
             //<>//
  // circle size legend
  fill(0, 20, 0);
  textAlign(CENTER, CENTER);
  text("Municipality Area", 1500, 300);

  noStroke();
  textAlign(RIGHT, CENTER);
  int nExamples = 6;
  float y = 340;
  for (int i=0; i<nExamples; i++) {
    float amt = 1.0f - (float)i/(nExamples - 1);
    float radius = lerp(minRadius, maxRadius, amt);
    
    ellipseMode(RADIUS);
    circle(1500 + radius, y, radius);
    int labelValue = (int)(minArea + amt*(maxArea - minArea));
    text(labelValue, 1490, y);
    y += 2 * radius;//maxIslandRadius;
  }

  y += 70;
  textAlign(CENTER, CENTER);
  text("Number of Kinship Ties", 1500, y);

  float maxTies = kinshipTies.getMaxKinshipTies();
  int step = (int) (maxTies / 10);
  float baseWeight = 0.01f;
  stroke(0, 20, 0);
  for (int i = 1; i < 11; i++)
  {
    strokeWeight(baseWeight + 0.1f*i*step);
    line(1480, y+(20*i), 1540, y+(20*i));
    text(i*step, 1460, y+(20*i)-1);
  }
}


 public void keyPressed() {
  if (key == ' ') {
    println("current scale: ", panZoomMap.scale, " current translation: ", panZoomMap.translateX, "x", panZoomMap.translateY);
  }
}


 public void mousePressed() {
  if (highlightedMunicipality != "") {
    if (selectedMunicipality.equals(highlightedMunicipality))
    {
      selectedMunicipality = "";
      println("Deselected: " + highlightedMunicipality);
    }
    else 
    {
      selectedMunicipality = highlightedMunicipality;
      println("Selected: " + selectedMunicipality);
    }
  }
  panZoomMap.mousePressed();
}


 public void mouseDragged() {
  panZoomMap.mouseDragged();
}


 public void mouseWheel(MouseEvent e) {
  panZoomMap.mouseWheel(e);
}


// === SOME HELPER ROUTINES FOR EASIER ACCESS TO FREQUENTLY NEEDED DATA IN THE TABLES ===

 public float getLatitude(String municipalityName) {
  TableRow r = locationTable.findRow(municipalityName, "Municipality");
  return r.getFloat("Latitude");
}

 public float getLongitude(String municipalityName) {
  TableRow r = locationTable.findRow(municipalityName, "Municipality");
  return r.getFloat("Longitude");
}

 public float getArea01(String municipalityName) {
  TableRow popRow = populationTable.findRow(municipalityName, "Municipality");
  int area = popRow.getInt("Area");
  float area_01 = (area - minArea) / (maxArea - minArea);
  return area_01;
}

// TODO: Update this based on your own radius calculation to make sure that the mouse selection
// routines work
 public float getRadius(String municipalityName) {
  float minRadius = 3;
  float maxRadius = 28;
  float amt = getArea01(municipalityName);
  return lerp(minRadius, maxRadius, amt);
}

// Returns the municipality currently under the mouse cursor so that it can be highlighted or selected
// with a mouse click.  If the municipalities overlap and more than one is under the cursor, the
// smallest municipality will be returned, since this is usually the hardest one to select.
 public String getMunicipalityUnderMouse() {
  float smallestRadiusSquared = Float.MAX_VALUE;
  String underMouse = "";
  for (int i=0; i<locationTable.getRowCount(); i++) {
    TableRow rowData = locationTable.getRow(i);
    String municipality = rowData.getString("Municipality");
    float latitude = rowData.getFloat("Latitude");
    float longitude = rowData.getFloat("Longitude");
    float screenX = panZoomMap.longitudeToScreenX(longitude);
    float screenY = panZoomMap.latitudeToScreenY(latitude);
    float distSquared = (mouseX-screenX)*(mouseX-screenX) + (mouseY-screenY)*(mouseY-screenY);
    float radius = getRadius(municipality);
    float radiusSquared = constrain(radius*radius, 1, height);
    if ((distSquared <= radiusSquared) && (radiusSquared < smallestRadiusSquared)) {
      underMouse = municipality;
      smallestRadiusSquared = radiusSquared;
    }
  }
  return underMouse;  
}



// === DATA PROCESSING ROUTINES ===

 public void loadRawDataTables() {
  locationTable = loadTable("FSM-municipality-locations.csv", "header");
  println("Location table:", locationTable.getRowCount(), "x", locationTable.getColumnCount()); 
  
  populationTable = loadTable("FSM-municipality-populations.csv", "header");
  println("Population table:", populationTable.getRowCount(), "x", populationTable.getColumnCount()); 
}


 public void computeDerivedData() {
  // lookup min/max data ranges for the variables we will want to depict
  minLatitude = TableUtils.findMinFloatInColumn(locationTable, "Latitude");
  maxLatitude = TableUtils.findMaxFloatInColumn(locationTable, "Latitude");
  println("Latitude range:", minLatitude, "to", maxLatitude);

  minLongitude = TableUtils.findMinFloatInColumn(locationTable, "Longitude");
  maxLongitude = TableUtils.findMaxFloatInColumn(locationTable, "Longitude");
  println("Longitude range:", minLongitude, "to", maxLongitude);

  minPop1980 = TableUtils.findMinFloatInColumn(populationTable, "Population 1980 Census");
  maxPop1980 = TableUtils.findMaxFloatInColumn(populationTable, "Population 1980 Census");
  println("Pop 1980 range:", minPop1980, "to", maxPop1980);
  
  minPop1994 = TableUtils.findMinFloatInColumn(populationTable, "Population 1994 Census");
  maxPop1994 = TableUtils.findMaxFloatInColumn(populationTable, "Population 1994 Census");
  println("Pop 1994 range:", minPop1994, "to", maxPop1994);

  minPop2000 = TableUtils.findMinFloatInColumn(populationTable, "Population 2000 Census");
  maxPop2000 = TableUtils.findMaxFloatInColumn(populationTable, "Population 2000 Census");
  println("Pop 2000 range:", minPop2000, "to", maxPop2000);

  minPop2010 = TableUtils.findMinFloatInColumn(populationTable, "Population 2010 Census");
  maxPop2010 = TableUtils.findMaxFloatInColumn(populationTable, "Population 2010 Census");
  println("Pop 2010 range:", minPop2010, "to", maxPop2010);

  minArea = TableUtils.findMinFloatInColumn(populationTable, "Area");
  maxArea = TableUtils.findMaxFloatInColumn(populationTable, "Area");
  println("Area range:", minArea, "to", maxArea);
}
/* CSci-5609 Support Code created by Prof. Dan Keefe, Fall 2023

Routines for identifying and accessing Paafu kinship relationships between islands
*/



// This class combines Paafu direction data with the locations of islands to indentify kinship 
// relationships between the islands.  In Paafu, islands that lie in the same direction are 
// considered to be tied together through a bond of kinship.
class KinshipTies {

  // The constructor analyses the direction and location data to find kinship ties, which can later
  // be accessed through the getKinshipTies*() functions.
  public KinshipTies(PaafuDirections paafuDirections, Table locationTable) {
    buildKinshipDataStructure(paafuDirections, locationTable);
  }

  
  // Returns an ordered list (i.e., sorted by distance from the startingMunicipality) of the 
  // municipalities that you will find when starting at the startingMunicipality and traveling
  // (approximately) in the direction of paafuDirection.  An empty ArrayList is returned if
  // there are no kinship ties for the specified direction.
  public ArrayList<String> getKinshipTiesForDirection(String startingMunicipality, String paafuDirection) {
    return kinshipData.get(startingMunicipality).get(paafuDirection);
  }
  
  
  // Returns all of the kinship ties for a given municipality organized by Paafu direction.  This is
  // the same information as provided in the previous function, which accesses the data for just a single
  // direction.  This function returns a HashMap that provides access to the data for ALL directions.
  // Example to loop through the HashMap, to access all kinship ties for the island of Weno (Moen):
  //    String municipality1 = "Weno (Moen)";
  //    HashMap<String, ArrayList<String>> kinshipTiesByDirection = kinshipTies.getKinshipTies(municipality1);
  //    for (String paafuDirection : kinshipTiesByDirection.keySet()) {
  //      ArrayList<String> municipalityList = kinshipTiesByDirection.get(paafuDirection);
  //      if (municipalityList.size() > 0) {
  //        println("From " + municipality1 + " in direction " + paafuDirection + ":");
  //        for (String municipality2 : municipalityList) {
  //          println("  " + municipality2);
  //        }
  //      }
  //    }
  public HashMap<String, ArrayList<String>> getKinshipTies(String municipality) {
    return kinshipData.get(municipality); 
  }


    
  // Returns the maximum number of kinship ties found in the data.  In other words, the max number of
  // islands found in a single direction, across the whole dataset.
  public int getMaxKinshipTies() {
    return maxKinshipTies; 
  }
    
    
  // internal method to build the kinship data structure
   public void buildKinshipDataStructure(PaafuDirections paafuDirections, Table locationTable) {
    kinshipData = new HashMap<String, HashMap<String, ArrayList<String>>>();
    maxKinshipTies = 0;

    for (int m1=0; m1<locationTable.getRowCount(); m1++) {
      HashMap<String, ArrayList<String>> kinshipForM1 = new HashMap<String, ArrayList<String>>();
      TableRow m1Row = locationTable.getRow(m1);
      String m1Name = m1Row.getString("Municipality");
      float m1Lat = m1Row.getFloat("Latitude");
      float m1Long = m1Row.getFloat("Longitude");
      
      for (int d=0; d<paafuDirections.getDirectionCount(); d++) {
        String direction = paafuDirections.getDirection(d);
        ArrayList<MunicipalityWithDistance> municipalitiesInDirection = new ArrayList<MunicipalityWithDistance>();
        for (int m2=0; m2<locationTable.getRowCount(); m2++) {        
          if (m2 != m1) {
            TableRow m2Row = locationTable.getRow(m2);
            float m2Lat = m2Row.getFloat("Latitude");
            float m2Long = m2Row.getFloat("Longitude");
            float angle = paafuDirections.getAngleFromTo(m1Lat, m1Long, m2Lat, m2Long);
            String m1ToM2Direction = paafuDirections.getDirection(angle);
            if (m1ToM2Direction == direction) {
              MunicipalityWithDistance mwd = new MunicipalityWithDistance();
              mwd.municipality = m2Row.getString("Municipality");;
              mwd.distance = MathUtils.getDistanceFromTo(m1Lat, m1Long, m2Lat, m2Long);
              municipalitiesInDirection.add(mwd);
            }
          }
        } // end of gathering islands that lie along this paafu direction 
        
        // sort the municipalities in this direction by distance
        Collections.sort(municipalitiesInDirection);
        // save the result in simple list of strings
        ArrayList<String> sortedMunicipalities = new ArrayList<String>();
        for (MunicipalityWithDistance m : municipalitiesInDirection) {
          sortedMunicipalities.add(m.municipality);
        }
        if (sortedMunicipalities.size() > maxKinshipTies) {
          maxKinshipTies = sortedMunicipalities.size(); 
        }
        
        kinshipForM1.put(direction, sortedMunicipalities);
      } // end for each paafu direction around m1
      
      kinshipData.put(m1Name, kinshipForM1);
    } // end for each island in the location table
  }
  
  
  // temporary class to help with sorting municipalities by distance while building the datastructure
  class MunicipalityWithDistance implements Comparable<MunicipalityWithDistance>{
    String municipality;
    Float distance;
    
    public int compareTo(MunicipalityWithDistance o) {
        return this.distance.compareTo(o.distance);
    }
  }
  
  // The data are stored internally as a double hashmap of arraylists so that lookups can be done
  // based on the name of the starting municipality and the direction to travel from that starting
  // location, like this:
  // ArrayList<String> municipalatiesInDirection = kinshipData.get(startingMunicipalityName).get(paafuDirectionName);
  // The list that is returned is sorted.
  HashMap<String, HashMap<String, ArrayList<String>>> kinshipData;
  int maxKinshipTies;
}
/* CSci-5609 Support Code created by Prof. Dan Keefe, Fall 2023

Routines for working with the Lab Color Space in Processing
*/




// Like Processing's built-in lerpColor() function, this function calculates a color
// between two colors at a specified increment.  The amt parameter is the amount to
// interpolate between the two values where 0.0 is equal to the first color, 0.1 is
// very near the first color, 0.5 is halfway between the two colors, etc.
// The key difference in this function is that the color interpolation is done in
// the perceptually uniform Lab color space rather than RGB space.
 public int lerpColorLab(int c1, int c2, float amt) {
  // convert input colors to Lab space
  float[] lab1 = colorToLab(c1);
  float[] lab2 = colorToLab(c2);
  
  // linearly interpolate the three L, a, b parmeters to find the in-between color
  // in Lab space
  float[] labNew = new float[3];
  labNew[0] = lerp(lab1[0], lab2[0], amt);
  labNew[1] = lerp(lab1[1], lab2[1], amt);
  labNew[2] = lerp(lab1[2], lab2[2], amt);
  
  // convert this Lab color back into a regular rgb color for drawing on the screen
  int c = labToColor(labNew);
  return c;
}


// converts a color stored in processing's built-in color type to its Lab representation
public float[] colorToLab(int c) {
  pushStyle();
  colorMode(RGB, 1, 1, 1);
  float[] rgb01 = { red(c), green(c), blue(c) };
  float[] lab = rgb01ToLab(rgb01); 
  popStyle();
  return lab;
}

// converts a color defined in Lab space to rgb space and returns the result as a Processing color
public int labToColor(float[] lab) {
  float[] rgb01 = labToRgb01(lab);    
  pushStyle();
  colorMode(RGB, 1, 1, 1);
  int c = color(rgb01[0], rgb01[1], rgb01[2]);
  popStyle();
  return c;
}



// ----- BEGIN EXTERNAL CODE FOR RGB-LAB CONVERSION (including some minor edits) -----
// https://github.com/antimatter15/rgb-lab

/*
MIT License
Copyright (c) 2014 Kevin Kwok <antimatter15@gmail.com>
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// the following functions are based off of the pseudocode
// found on www.easyrgb.com
  
 public float[] labToRgb01(float[] lab) {
  double y = (lab[0] + 16.0f) / 116.0f;
  double x = lab[1] / 500.0f + y;
  double z = y - lab[2] / 200.0f;
  double r, g, b;
  
  x = 0.95047f * ((x * x * x > 0.008856f) ? x * x * x : (x - 16.0f / 116.0f) / 7.787f);
  y = 1.00000f * ((y * y * y > 0.008856f) ? y * y * y : (y - 16.0f / 116.0f) / 7.787f);
  z = 1.08883f * ((z * z * z > 0.008856f) ? z * z * z : (z - 16.0f / 116.0f) / 7.787f);
  
  r = x * 3.2406f + y * -1.5372f + z * -0.4986f;
  g = x * -0.96890f + y * 1.8758f + z * 0.0415f;
  b = x * 0.05570f + y * -0.2040f + z * 1.0570f;
  
  r = (r > 0.0031308f) ? (1.055f * Math.pow(r, 1.0f / 2.4f) - 0.055f) : 12.92f * r;
  g = (g > 0.0031308f) ? (1.055f * Math.pow(g, 1.0f / 2.4f) - 0.055f) : 12.92f * g;
  b = (b > 0.0031308f) ? (1.055f * Math.pow(b, 1.0f / 2.4f) - 0.055f) : 12.92f * b;
  
  float[] rgb = new float[3];
  rgb[0] = constrain((float)r, 0, 1);
  rgb[1] = constrain((float)g, 0, 1);
  rgb[2] = constrain((float)b, 0, 1);
  return rgb;
}


 public float[] rgb01ToLab(float[] rgb) {
  double r = rgb[0];
  double g = rgb[1];
  double b = rgb[2];
  double x, y, z;

  r = (r > 0.04045f) ? Math.pow((r + 0.055f) / 1.055f, 2.4f) : r / 12.92f;
  g = (g > 0.04045f) ? Math.pow((g + 0.055f) / 1.055f, 2.4f) : g / 12.92f;
  b = (b > 0.04045f) ? Math.pow((b + 0.055f) / 1.055f, 2.4f) : b / 12.92f;

  x = (r * 0.4124f + g * 0.3576f + b * 0.1805f) / 0.95047f;
  y = (r * 0.2126f + g * 0.7152f + b * 0.0722f) / 1.00000f;
  z = (r * 0.0193f + g * 0.1192f + b * 0.9505f) / 1.08883f;

  x = (x > 0.008856f) ? Math.pow(x, 1.0f / 3.0f) : (7.787f * x) + 16.0f / 116.0f;
  y = (y > 0.008856f) ? Math.pow(y, 1.0f / 3.0f) : (7.787f * y) + 16.0f / 116.0f;
  z = (z > 0.008856f) ? Math.pow(z, 1.0f / 3.0f) : (7.787f * z) + 16.0f / 116.0f;

  float[] lab = new float[3];
  lab[0] = (float)(116.0f * y) - 16.0f;
  lab[1] = (float)(500.0f * (x - y));
  lab[2] = (float)(200.0f * (y - z));

  return lab;
}
/* CSci-5609 Support Code created by Prof. Dan Keefe, Fall 2023

Some useful utility functions for working with spatial data
*/

static class MathUtils {

  // Returns the Euclidian distance between two points (x1,y1) and (x2,y2) 
  static public float getDistanceFromTo(float x1, float y1, float x2, float y2) {
    float dx = x2 - x1;
    float dy = y2 - y1;
    return sqrt(dx*dx + dy*dy);
  }
  
  // If the angle is outside the range -180 to +180, the function returns an equivalent angle within
  // the range -180 to +180.
  static public float angleToPlusMinus180(float a) {
    while (a <= -180) {
      a += 360; 
    }
    while (a > 180) {
      a -= 360; 
    }
    return a;
  }
   
}
/* CSci-5609 Support Code created by Prof. Dan Keefe, Fall 2023

An object that models a Paafu circle.  The angles and names for each direction
are read from a data table.  The class provides methods to access and work
with these data.
*/
 //<>//
public class PaafuDirections {

  // Initializes the class by loading data from the Paafu-Directions.csv file
  public PaafuDirections() {
    directionTable = loadTable("Paafu-Directions.csv", "header");
    println("Paafu table:", directionTable.getRowCount(), "x", directionTable.getColumnCount()); 
  } 
  
  // Returns the angle in degrees relative to Wenewenenfuhemakit (i.e., North) for the provided 
  // Paafu direction.  the angle ranges from -180 to +180 and increases positively when rotating
  // to the East of North and decreases negatively when rotating to the West of North.
  public float getAngle(String directionName) {
    TableRow r = directionTable.findRow(directionName, "Direction");
    return r.getFloat("Angle");
  }
  
  // Returns the closest Paafu direction to the angle, which is specified in degrees east of north.
  public String getDirection(float angle) {
    int closestID = 0;
    float closestDiff = abs(directionTable.getRow(0).getFloat("Angle") - angle);
    for (int r=1; r<directionTable.getRowCount(); r++) {
      float diff = abs(angle - directionTable.getRow(r).getFloat("Angle"));
      if (diff < closestDiff) {
        closestID = r;
        closestDiff = diff;
      }
    }
    return directionTable.getRow(closestID).getString("Direction");
  }
  
  // Returns the angle (i.e., heading) to take to move from the point(fromLatitude, fromLongitude) to
  // a new location (toLatitude, toLongitude).  Assumes zero degrees points North and angles increase
  // when rotating to the East from North and decrease when rotating to the West of North.
  public float getAngleFromTo(float fromLatitude, float fromLongitude, float toLatitude, float toLongitude) {
    float dx = toLongitude - fromLongitude;
    float dy = toLatitude - fromLatitude;
    float a = atan2(dy,dx);
    a = -a + PI/2.0f; // invert and shift so a=0 points north and angles increase rotating east
    a = degrees(a);  // convert to degrees
    a = MathUtils.angleToPlusMinus180(a);    
    return a;
  }
  
  // Returns the name of the closest Paafu direction to take to move from one location to another
  public String getDirectionFromTo(float fromLatitude, float fromLongitude, 
                                   float toLatitude, float toLongitude) 
  {
    float a = getAngleFromTo(fromLatitude, fromLongitude, toLatitude, toLongitude);
    return getDirection(a);
  }
  
  
  public float getDirectionCount() {
    return directionTable.getRowCount(); 
  }

  public String getDirection(int id) {
    return directionTable.getRow(id).getString("Direction"); 
  }
  
  public float getAngle(int id) {
    return directionTable.getRow(id).getFloat("Angle");
  } 
   
  Table directionTable;
}
/* CSci-5609 Support Code created by Prof. Dan Keefe, Fall 2023

This class extends the PanZoomPage base class.  Please read the comments at the top of
that file before continuing...

The PanZoomMap class provides a special wrapper around a PanZoomPage.  It automatically fits
a rectangular region defined in earth coordinates, i.e., (latitude, longitude), into the
virtual page provided by a PanZoomPage.  This is useful when working with data that are
supplied in (lat,long) coordinates.  The PanZoomMap class provides functions for converting
(lat,long) to the Page coordinate space (the virtual page of the PanZoomPage) AND also for
converting (lat,long) all the way to Processing's Screen coordinate space (i.e., pixels).

When you construct a PanZoomMap, you need to provide the coordinates of the rectagle of the map
(i.e., min and max latitude and longitude).  These coordinates do not need to carve out a square.
It can be any rectangle.  The PanZoomMap class will auto-fit that rectangle into the center of
its square-shaped virtual page on startup.  The approach to drawing graphics defined in the 
(lat,long) coordinate system is analogous to that used in the PanZoomPage base class.  The
difference is simply that PanZoomMap provides coordinate conversion routines that work directly
with latitude and longitude.

Since the class was created to support visualizations in Micronesia, it (currently) assumes 
latitude is North of the Equator and longitude is East of the Prime Meridian.  
TODO: Test with negative values for lat,long and document a convention; be careful when 
importing W longitudes and S latitudes, which are often stored as positive numbers but 
increasing from right to left and top to bottom, the opposite of what this class assumes.

class PanZoomMap extends PanZoomPage {
  
  public PanZoomMap(float minLat, float minLong, float maxLat, float maxLong) {
    minLatitude = minLat;
    minLongitude = minLong;
    maxLatitude = maxLat;
    maxLongitude = maxLong;
    
    mapScale = 1;
    mapTranslateX = 0;
    mapTranslateY = 0;
    
    fitMapOnPage();
  }
  
  void fitMapOnPage() {
    float deltaLat = maxLatitude - minLatitude;
    float deltaLong = maxLongitude - minLongitude;
    if (deltaLong >= deltaLat) {
      mapScale = 1.0 / deltaLong;
      mapTranslateX = 0;
      mapTranslateY = (1.0 - deltaLat * mapScale) / 2.0;
    }
    else {
      mapScale = 1.0 / deltaLat;
      mapTranslateY = 0;
      mapTranslateX = (1.0 - deltaLong * mapScale) / 2.0;      
    }
  }
  
  float longitudeToPageX(float longitude) {
    float relativeLong = longitude - minLongitude;
    return relativeLong * mapScale + mapTranslateX;
  }
  
  float latitudeToPageY(float latitude) {
    float relativeLat = latitude - minLatitude;
    return 1.0 - (relativeLat * mapScale + mapTranslateY);
  }
  
  float mapLengthToPageLength(float mapLen) {
    return mapLen * mapScale;
  }
  
  float pageXtoLongitude(float pageX) {
    return (pageX - mapTranslateX) / mapScale + minLongitude;
  }
  
  float pageYtoLatitude(float pageY) {
    return ((1.0 - pageY) - mapTranslateY) / mapScale + minLatitude;
  }
  
  float pageLengthToMapLength(float pageLen) {
    return pageLen / mapScale;
  }
  
  
  float longitudeToScreenX(float longitude) {
    float pageX = longitudeToPageX(longitude);
    return pageXtoScreenX(pageX);
  }
  
  float latitudeToScreenY(float latitude) {
    float pageY = latitudeToPageY(latitude);
    return pageYtoScreenY(pageY);
  }
  
  float mapLengthToScreenLength(float mapLen) {
    float pageLen = mapLengthToPageLength(mapLen);
    return pageLengthToScreenLength(pageLen); 
  }
  
  
  float screenXtoLongitude(float screenX) {
    float pageX = screenXtoPageX(screenX);
    return pageXtoLongitude(pageX);
  }
  
  float screenYtoLatitude(float screenY) {
    float pageY = screenYtoPageY(screenY);
    return pageYtoLatitude(pageY);
  }
  
  float screenLengthToMapLength(float screenLen) {
    float pageLen = screenLengthToPageLength(screenLen);
    return pageLengthToMapLength(pageLen); 
  }
  
  float mapScale;
  float mapTranslateX;
  float mapTranslateY;
  
  float minLatitude;
  float maxLatitude;
  float minLongitude;
  float maxLongitude;
}
*/


class PanZoomMap extends PanZoomPage {
  
  public PanZoomMap(float minLat, float minLong, float maxLat, float maxLong) {
    minLatitude = minLat;
    maxLatitude = maxLat;
    minLongitude = minLong;
    maxLongitude = maxLong;
    
    mapScale = 1;
    mapTranslateX = 0;
    mapTranslateY = 0;
    
    fitMapOnPage();
  }
  
   public void fitMapOnPage() {
    float deltaLat = maxLatitude - minLatitude;
    float deltaLong = maxLongitude - minLongitude;
    if (deltaLong >= deltaLat) {
      mapScale = 1.0f / deltaLong;
      mapTranslateX = 0;
      mapTranslateY = (1.0f - deltaLat * mapScale) / 2.0f;
    }
    else {
      mapScale = 1.0f / deltaLat;
      mapTranslateY = 0;
      mapTranslateX = (1.0f - deltaLong * mapScale) / 2.0f;      
    }
  }
  
   public float longitudeToPageX(float longitude) {
    float relativeLong = longitude - minLongitude;
    return relativeLong * mapScale + mapTranslateX;
  }
  
   public float latitudeToPageY(float latitude) {
    float relativeLat = latitude - minLatitude;
    return 1.0f - (relativeLat * mapScale + mapTranslateY);
  }
  
   public float mapLengthToPageLength(float mapLen) {
    return mapLen * mapScale;
  }
  
   public float pageXtoLongitude(float pageX) {
    return (pageX - mapTranslateX) / mapScale + minLongitude;
  }
  
   public float pageYtoLatitude(float pageY) {
    return (1.0f - pageY - mapTranslateY) / mapScale + minLatitude;
  }
  
   public float pageLengthToMapLength(float pageLen) {
    return pageLen / mapScale;
  }
  
  
   public float longitudeToScreenX(float longitude) {
    float pageX = longitudeToPageX(longitude);
    return pageXtoScreenX(pageX);
  }
  
   public float latitudeToScreenY(float latitude) {
    float pageY = latitudeToPageY(latitude);
    return pageYtoScreenY(pageY);
  }
  
   public float mapLengthToScreenLength(float mapLen) {
    float pageLen = mapLengthToPageLength(mapLen);
    return pageLengthToScreenLength(pageLen); 
  }
  
  
   public float screenXtoLongitude(float screenX) {
    float pageX = screenXtoPageX(screenX);
    return pageXtoLongitude(pageX);
  }
  
   public float screenYtoLatitude(float screenY) {
    float pageY = screenYtoPageY(screenY);
    return pageYtoLatitude(pageY);
  }
  
   public float screenLengthToMapLength(float screenLen) {
    float pageLen = screenLengthToPageLength(screenLen);
    return pageLengthToMapLength(pageLen); 
  }
  
  float mapScale;
  float mapTranslateX;
  float mapTranslateY;
  
  float minLatitude;
  float maxLatitude;
  float minLongitude;
  float maxLongitude;
}
/* CSci-5609 Visualization Support Code  created by Prof. Dan Keefe, Fall 2023

This class is useful for creating 2D visualizations that are larger than the screen
and require panning and zooming with the mouse.  The way it works is that you draw
your visualization using the coordinate system of the PanZoomPage, and this class
keeps track of how that coordinate system relates to Processing's coordinate system.
The virtual page is always a square.  The origin (0,0) is at the top-left corner, like
Processing's coordinate system, but unlike Processing, the bottom-right corner of
the page has coordinates (1,1).  In other words, the virtual page is exactly 1 unit
wide by 1 unit tall.  This means anything you wish to draw within the page should have
floating point coordinates in the range 0.0 to 1.0.  In many ways this makes drawing
graphics a lot easier than Processing's default, which is 1 unit = 1 pixel.  To put
an object in the middle of the virtual page, you simply place it at (0.5, 0.5) -- no
need to check the width and height of the window and then divide by two as you would
with Processing's default coordinate system.  When the class is constructed, it
automatically sets an appropriate scale so that the virtual page fills the processing
window.  The class is quite lightweight.  It does not actually do any drawing for you.
It simply provides routines to convert from virtual page coordinates to Processing's
screen coordinates.  The way to use these is to define your graphics using virtual
page coordinates.  Then, right before drawing the graphics, use the conversion
functions to transform those virtual page coordinates into screen coordinates taking
into account the current zoom level and panning.

The code below provides a complete working example use of the class.  Click and drag
the left mouse button to pan the virtual page, and scroll the mouse wheel up or down
to zoom in and out.  

PanZoomPage panZoomPage;

void setup() {
  size(1600, 900);
  panZoomPage = new PanZoomPage(); 
}

void draw() {
  background(100);
  
  // draw a white square that covers the entire virtual page
  fill(255);
  stroke(0);
  rectMode(CORNERS);
  rect(panZoomPage.pageXtoScreenX(0), panZoomPage.pageYtoScreenY(0),
       panZoomPage.pageXtoScreenX(1), panZoomPage.pageYtoScreenY(1));

  // draw a circle at the center of the page with a radius 0.25 times the width
  // of the page
  float radius = panZoomPage.pageLengthToScreenLength(0.25);
  float cx = panZoomPage.pageXtoScreenX(0.5);
  float cy = panZoomPage.pageYtoScreenY(0.5);
  fill(200,0,200);
  ellipseMode(RADIUS);
  circle(cx, cy, radius);  
}

void mousePressed() {
  panZoomPage.mousePressed();
}

void mouseDragged() {
  panZoomPage.mouseDragged();
}

void mouseWheel(MouseEvent e) {
  panZoomPage.mouseWheel(e);
}
*/
public class PanZoomPage { 
  
  public PanZoomPage() {
    scale = 1.0f;
    translateX = 0.0f;
    translateY = 0.0f;
    lastMouseX = 0;
    lastMouseY = 0;
  
    fitPageOnScreen(); 
  }
  
  
   public float pageXtoScreenX(float pageX) {
    return pageX * scale + translateX; 
  }
  
   public float pageYtoScreenY(float pageY) {
    return pageY * scale + translateY; 
  }
  
   public float pageLengthToScreenLength(float l) {
    return l * scale; 
  }
  
  
   public float screenXtoPageX(float screenX) {
    return (screenX - translateX) / scale;
  }
  
   public float screenYtoPageY(float screenY) {
    return (screenY - translateY) / scale;
  }
  
   public float screenLengthToPageLength(float l) {
    return l / scale; 
  }
  
   public void fitPageOnScreen() {
    if (width >= height) {
      scale = height;
      translateY = 0;
      translateX = (width - height) / 2.0f;
    }
    else {
      scale = width;
      translateX = 0;
      translateY = (height - width) / 2.0f;
    }
  }

   public void mousePressed() {
    if (mouseButton == LEFT) {
      lastMouseX = mouseX;
      lastMouseY = mouseY;
    }
  }
  
   public void mouseDragged() {
    if (mouseButton == LEFT) {
      int deltaX = mouseX - lastMouseX;
      int deltaY = mouseY - lastMouseY;
      translateX += deltaX;
      translateY += deltaY;
      lastMouseX = mouseX;
      lastMouseY = mouseY;
    }
  }

   public void mouseWheel(MouseEvent e)
  {
    float scaleDelta = 1.0f;
    if (e.getCount() > 0) {
      scaleDelta = 1.07f;
    } 
    else if (e.getCount() < 0) {
      scaleDelta = 0.93f;
    }
  
    if (scaleDelta != 1.0f) {
      translateX -= mouseX;
      translateY -= mouseY;
      scale *= scaleDelta;
      translateX *= scaleDelta;
      translateY *= scaleDelta;
      translateX += mouseX;
      translateY += mouseY;
    }
  }
  
  float scale = 1.0f;
  float translateX = 0.0f;
  float translateY = 0.0f;
  int lastMouseX = 0;
  int lastMouseY = 0;
}
/* CSci-5609 Visualization Support Code  created by Prof. Dan Keefe, Fall 2023

To size or color graphics based on data, we need to know min and max ranges for the data.
These utilities help to quickly calculate mins and maxes for data organized in tables.
*/
static class TableUtils {
  
   public static float findMinFloatInColumn(Table t, int column) {
    float[] values = t.getFloatColumn(column);
    float min = values[0];
    for (int i=0; i<values.length; i++) {
      if (values[i] < min) {
        min = values[i]; 
      }
    }
    return min;
  }

   public static float findMinFloatInColumn(Table t, String columnName) {
    return findMinFloatInColumn(t, t.getColumnIndex(columnName));
  }
  
   public static float findMaxFloatInColumn(Table t, int column) {
    float[] values = t.getFloatColumn(column);
    float max = values[0];
    for (int i=0; i<values.length; i++) {
      if (values[i] > max) {
        max = values[i]; 
      }
    }
    return max;
  }

   public static float findMaxFloatInColumn(Table t, String columnName) {
    return findMaxFloatInColumn(t, t.getColumnIndex(columnName));
  }

  static public boolean contains(int[] arr, int value) {
    for (int i : arr) {
      if (i == value) {
        return true;
      }
    }
    return false;
  }
  

  static public int[] findRowIndicesForTwoCriteria(Table t, final String value1, final int column1,
                                                   final String value2, final int column2) {
    int[] indices1 = t.findRowIndices(value1, column1);
    int[] indices2 = t.findRowIndices(value2, column2);
    int[] indicesOut = new int[t.getRowCount()];
    int count = 0;
    for (int r=0; r<t.getRowCount(); r++) {
      if ((contains(indices1, r)) && (contains(indices2, r))) {
        indicesOut[count] = r;
        count++;
      }
    }
    return PApplet.subset(indicesOut, 0, count);
  }

  
  static public int[] findRowIndicesForTwoCriteria(Table t, final String value1, final String column1,
                                                   final String value2, final String column2) {
    return findRowIndicesForTwoCriteria(t, value1, t.getColumnIndex(column1), value2, t.getColumnIndex(column2)); 
  }
  
  
  static public void printTable(Table t) {
     for (int r=0; r<t.getRowCount(); r++) {
       TableRow rowValues = t.getRow(r);
       for (int c=0; c<t.getColumnCount(); c++) {
         print(rowValues.getString(c));
         if (c < t.getColumnCount() -1) {
           print(", "); 
         }
       }
       println();
     }
  }
  
}


  public void settings() { size(1600, 900); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Paafu2" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
