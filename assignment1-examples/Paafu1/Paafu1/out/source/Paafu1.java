/* autogenerated by Processing revision 1286 on 2023-01-25 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Comparator;
import java.util.Collections;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Paafu1 extends PApplet {

/* CSci-5609 Assignment 1: Visualization of the Islands of Micronesia
*/




// === GLOBAL VARIABLES ===

// Raw data tables
Table locationTable;
Table populationTable;

// Derived data: mins and maxes for each data variable
float minLatitude, maxLatitude;
float minLongitude, maxLongitude;
float minPop1980, maxPop1980;
float minPop1994, maxPop1994;
float minPop2000, maxPop2000;
float minPop2010, maxPop2010;
float minArea, maxArea;

// Graphics objects
PanZoomMap panZoomMap;



// === PROCESSING BUILT-IN FUNCTIONS ===
 public void setup() {
  // size of the graphics window
  /* size commented out by preprocessor */;

  // load data in from disk and do any data processing
  loadRawDataTables();
  computeDerivedData();
  
  // these coordinates define a rectangular region for the map that happens to be
  // centered around Micronesia
  panZoomMap = new PanZoomMap(5.2f, 138.0f, 10.0f, 163.1f); 
  ellipseMode(RADIUS);

  setup_ui_array();
}

class UIValue
{
  String name;
  float lon, lat, area, ulx, uly, brx, bry;
  public UIValue(String name, float lon, float lat, float area)
  {
    this.name = name;
    this.lon = lon;
    this.lat = lat;
    this.area = area;
  }

  public void setRectBounds(float ulx, float uly, float brx, float bry)
  {
    this.ulx = ulx;
    this.uly = uly;
    this.brx = brx;
    this.bry = bry;
  }
}

UIValue[] ui;
Float[] ui_coords = new Float[4];
int num_islands;
boolean ui_open = false;
PFont ui_head;
 public void setup_ui_array()
{
  ui_coords[0] = 0.0f;
  ui_coords[1] = 0.0f;
  ui_coords[2] = width / 7.0f;
  ui_coords[3] = height / 18.0f;

  num_islands = locationTable.getRowCount();
  ui = new UIValue[num_islands];
  for (int i = 0; i < num_islands; i++)
  {
    TableRow cur = locationTable.getRow(i);
    ui[i] = new UIValue(
      cur.getString(0),
      cur.getFloat(1),
      cur.getFloat(2),
      populationTable.getRow(i).getFloat(6)
    );
  }

  ui_head = createFont("Times New Roman", 12, true);
}

 public void draw_ui()
{
  fill(40);
  rect(
    ui_coords[0],
    ui_coords[1],
    ui_coords[2],
    ui_coords[3]
  );

  fill(100, 200, 30);
  textAlign(CENTER);
  textFont(ui_head, 24);
  text("Islands (Click)", ui_coords[2]/2, ui_coords[3]/1.5f);
  textFont(ui_head, 12);
  fill(40);
  if (ui_open)
  {
    int curr_isle = 0;
    float jump = (height - ui_coords[3]) / (num_islands*0.5f);
    for (int i = 0; i < num_islands / 2; i++)
    {
      for (int j = 0; j < 2; j++)
      {
        ui[curr_isle].setRectBounds(
          j*ui_coords[2]*0.5f,
          ui_coords[3] + i*jump,
          (j+1)*ui_coords[2]*0.5f,
          ui_coords[3] + (i+1)*jump
        );
        fill(40);
        rect(
          ui[curr_isle].ulx,
          ui[curr_isle].uly,
          ui[curr_isle].brx,
          ui[curr_isle].bry
        );
        fill(100, 200, 30);
        String[] toks = ui[curr_isle].name.split(" ", 2);
        if (toks.length == 2)
        {
          text(
            toks[0], 
            lerp(ui[curr_isle].ulx, ui[curr_isle].brx, 0.5f),
            lerp(ui[curr_isle].uly, ui[curr_isle].bry, 0.4f)
          );

          text(
            toks[1], 
            lerp(ui[curr_isle].ulx, ui[curr_isle].brx, 0.5f),
            lerp(ui[curr_isle].uly, ui[curr_isle].bry, 0.8f)
          );
        }
        else 
        {
          text(
            toks[0], 
            lerp(ui[curr_isle].ulx, ui[curr_isle].brx, 0.5f),
            lerp(ui[curr_isle].uly, ui[curr_isle].bry, 0.6f)
          );
        }
          
        curr_isle++;
      }
    }
  }
}

 public void draw() {
  // clear the screen
  background(0);
  
  // draw the bounds of the map
  fill(40);
  stroke(100);
  rectMode(CORNERS);
  float x1 = panZoomMap.longitudeToScreenX(138.0f);
  float y1 = panZoomMap.latitudeToScreenY(5.2f);
  float x2 = panZoomMap.longitudeToScreenX(163.1f);
  float y2 = panZoomMap.latitudeToScreenY(10.0f);
  rect(x1, y1, x2, y2);
  
  // Example of drawing just one island.  You'll want to replace this with your own visualization.
  
  // the island of Weno (Moan) is located at 7°27′0″ N, 151°51′0″ E or in decimal (7.45, 151.85)
  // let's draw a circle centered at that location.
  // float cx = panZoomMap.longitudeToScreenX(151.85);
  // float cy = panZoomMap.latitudeToScreenY(7.45);
  
  // using OpenStreetMap, I estimate the West edge of the island is at long=151.8376 and
  // the East edge is at long=151.8376, a difference of just 0.0641 degrees.  We can use
  // this value to create a circle that approximates the size of the island like below.
  // However, it is a pretty small island--zoom in to make it bigger.
  // float radius = panZoomMap.mapLengthToScreenLength(0.0641) / 2.0;
  // fill(200,0,200);
  // ellipseMode(RADIUS);
  // circle(cx, cy, radius);

  /*
    Layout of the data is <name_string> <lat_float> <long_float>
  */
  ArrayList<Float[]> pairs = new ArrayList<Float[]>();
  for (int i = 0; i < locationTable.getRowCount(); i++) 
  {
    TableRow loc_row = locationTable.getRow(i);
    String island_name = loc_row.getString(0);
    float lat = loc_row.getFloat(1);
    float lon = loc_row.getFloat(2);

    float cx = panZoomMap.longitudeToScreenX(lon);
    float cy = panZoomMap.latitudeToScreenY(lat);

    /* 
      Use the max and min areas here -- lerp between
    */
    float scale = 50000;
    float area = populationTable.getRow(i).getFloat(6) / scale;

    float scaled_min = minArea / scale;
    float scaled_max = maxArea / scale;

    // println(scaled_min, scaled_max);

    float area_normalized = (area - scaled_min) / (scaled_max - scaled_min);

    float rad = panZoomMap.mapLengthToScreenLength(lerp(scaled_min, scaled_max, area_normalized)) / 2.0f;

    Float[] f = {cx, cy, rad};
    pairs.add(f);
  }

  Collections.sort(pairs, new IslandComparator());

  for (int i = 0; i < locationTable.getRowCount(); i++)
  {
    Float[] f = pairs.get(i);
    fill(200, 0, 200);
    circle(f[0], f[1], f[2]);
  }

  draw_ui();
}

public class IslandComparator implements Comparator<Float[]>
{
  @Override
  public int compare(Float[] f1, Float[] f2)
  {
    return f2[2].compareTo(f1[2]);
  }
}


 public void keyPressed() {
  if (key == ' ') {
    println("current scale: ", panZoomMap.scale, " current translation: ", panZoomMap.translateX, "x", panZoomMap.translateY);
  }
}


 public void mousePressed() {
  panZoomMap.mousePressed();
  if (mouseX >= ui_coords[0] && 
      mouseX <= ui_coords[2] &&
      mouseY >= ui_coords[1] &&
      mouseY <= ui_coords[3])
  {
    ui_open = !ui_open;
  }
}


 public void mouseDragged() {
  panZoomMap.mouseDragged();
}


 public void mouseWheel(MouseEvent e) {
  panZoomMap.mouseWheel(e);
}




// === DATA PROCESSING ROUTINES ===

 public void loadRawDataTables() {
  locationTable = loadTable("FSM-municipality-locations.csv", "header");
  println("Location table:", locationTable.getRowCount(), "x", locationTable.getColumnCount()); 
  
  populationTable = loadTable("FSM-municipality-populations.csv", "header");
  println("Population table:", populationTable.getRowCount(), "x", populationTable.getColumnCount()); 
}


 public void computeDerivedData() {
  // calculate min/max data ranges for the variables we will want to depict
  minLatitude = TableUtils.findMinFloatInColumn(locationTable, "Latitude");
  maxLatitude = TableUtils.findMaxFloatInColumn(locationTable, "Latitude");
  println("Latitude range:", minLatitude, "to", maxLatitude);

  minLongitude = TableUtils.findMinFloatInColumn(locationTable, "Longitude");
  maxLongitude = TableUtils.findMaxFloatInColumn(locationTable, "Longitude");
  println("Longitude range:", minLongitude, "to", maxLongitude);

  minPop1980 = TableUtils.findMinFloatInColumn(populationTable, "Population 1980 Census");
  maxPop1980 = TableUtils.findMaxFloatInColumn(populationTable, "Population 1980 Census");
  println("Pop 1980 range:", minPop1980, "to", maxPop1980);
  
  minPop1994 = TableUtils.findMinFloatInColumn(populationTable, "Population 1994 Census");
  maxPop1994 = TableUtils.findMaxFloatInColumn(populationTable, "Population 1994 Census");
  println("Pop 1994 range:", minPop1994, "to", maxPop1994);

  minPop2000 = TableUtils.findMinFloatInColumn(populationTable, "Population 2000 Census");
  maxPop2000 = TableUtils.findMaxFloatInColumn(populationTable, "Population 2000 Census");
  println("Pop 2000 range:", minPop2000, "to", maxPop2000);

  minPop2010 = TableUtils.findMinFloatInColumn(populationTable, "Population 2010 Census");
  maxPop2010 = TableUtils.findMaxFloatInColumn(populationTable, "Population 2010 Census");
  println("Pop 2010 range:", minPop2010, "to", maxPop2010);

  minArea = TableUtils.findMinFloatInColumn(populationTable, "Area");
  maxArea = TableUtils.findMaxFloatInColumn(populationTable, "Area");
  println("Area range:", minArea, "to", maxArea);
}
/* CSci-5609 Support Code created by Prof. Dan Keefe, Fall 2023

This class extends the PanZoomPage base class.  Please read the comments at the top of
that file before continuing...

The PanZoomMap class provides a special wrapper around a PanZoomPage.  It automatically fits
a rectangular region defined in earth coordinates, i.e., (latitude, longitude), into the
virtual page provided by a PanZoomPage.  This is useful when working with data that are
supplied in (lat,long) coordinates.  The PanZoomMap class provides functions for converting
(lat,long) to the Page coordinate space (the virtual page of the PanZoomPage) AND also for
converting (lat,long) all the way to Processing's Screen coordinate space (i.e., pixels).

When you construct a PanZoomMap, you need to provide the coordinates of the rectagle of the map
(i.e., min and max latitude and longitude).  These coordinates do not need to carve out a square.
It can be any rectangle.  The PanZoomMap class will auto-fit that rectangle into the center of
its square-shaped virtual page on startup.  The approach to drawing graphics defined in the 
(lat,long) coordinate system is analogous to that used in the PanZoomPage base class.  The
difference is simply that PanZoomMap provides coordinate conversion routines that work directly
with latitude and longitude.

Since the class was created to support visualizations in Micronesia, it (currently) assumes 
latitude is North of the Equator and longitude is East of the Prime Meridian.  
TODO: Test with negative values for lat,long and document a convention; be careful when 
importing W longitudes and S latitudes, which are often stored as positive numbers but 
increasing from right to left and top to bottom, the opposite of what this class assumes.

class PanZoomMap extends PanZoomPage {
  
  public PanZoomMap(float minLat, float minLong, float maxLat, float maxLong) {
    minLatitude = minLat;
    minLongitude = minLong;
    maxLatitude = maxLat;
    maxLongitude = maxLong;
    
    mapScale = 1;
    mapTranslateX = 0;
    mapTranslateY = 0;
    
    fitMapOnPage();
  }
  
  void fitMapOnPage() {
    float deltaLat = maxLatitude - minLatitude;
    float deltaLong = maxLongitude - minLongitude;
    if (deltaLong >= deltaLat) {
      mapScale = 1.0 / deltaLong;
      mapTranslateX = 0;
      mapTranslateY = (1.0 - deltaLat * mapScale) / 2.0;
    }
    else {
      mapScale = 1.0 / deltaLat;
      mapTranslateY = 0;
      mapTranslateX = (1.0 - deltaLong * mapScale) / 2.0;      
    }
  }
  
  float longitudeToPageX(float longitude) {
    float relativeLong = longitude - minLongitude;
    return relativeLong * mapScale + mapTranslateX;
  }
  
  float latitudeToPageY(float latitude) {
    float relativeLat = latitude - minLatitude;
    return 1.0 - (relativeLat * mapScale + mapTranslateY);
  }
  
  float mapLengthToPageLength(float mapLen) {
    return mapLen * mapScale;
  }
  
  float pageXtoLongitude(float pageX) {
    return (pageX - mapTranslateX) / mapScale + minLongitude;
  }
  
  float pageYtoLatitude(float pageY) {
    return ((1.0 - pageY) - mapTranslateY) / mapScale + minLatitude;
  }
  
  float pageLengthToMapLength(float pageLen) {
    return pageLen / mapScale;
  }
  
  
  float longitudeToScreenX(float longitude) {
    float pageX = longitudeToPageX(longitude);
    return pageXtoScreenX(pageX);
  }
  
  float latitudeToScreenY(float latitude) {
    float pageY = latitudeToPageY(latitude);
    return pageYtoScreenY(pageY);
  }
  
  float mapLengthToScreenLength(float mapLen) {
    float pageLen = mapLengthToPageLength(mapLen);
    return pageLengthToScreenLength(pageLen); 
  }
  
  
  float screenXtoLongitude(float screenX) {
    float pageX = screenXtoPageX(screenX);
    return pageXtoLongitude(pageX);
  }
  
  float screenYtoLatitude(float screenY) {
    float pageY = screenYtoPageY(screenY);
    return pageYtoLatitude(pageY);
  }
  
  float screenLengthToMapLength(float screenLen) {
    float pageLen = screenLengthToPageLength(screenLen);
    return pageLengthToMapLength(pageLen); 
  }
  
  float mapScale;
  float mapTranslateX;
  float mapTranslateY;
  
  float minLatitude;
  float maxLatitude;
  float minLongitude;
  float maxLongitude;
}
*/


class PanZoomMap extends PanZoomPage {
  
  public PanZoomMap(float minLat, float minLong, float maxLat, float maxLong) {
    minLatitude = minLat;
    maxLatitude = maxLat;
    minLongitude = minLong;
    maxLongitude = maxLong;
    
    mapScale = 1;
    mapTranslateX = 0;
    mapTranslateY = 0;
    
    fitMapOnPage();
  }
  
   public void fitMapOnPage() {
    float deltaLat = maxLatitude - minLatitude;
    float deltaLong = maxLongitude - minLongitude;
    if (deltaLong >= deltaLat) {
      mapScale = 1.0f / deltaLong;
      mapTranslateX = 0;
      mapTranslateY = (1.0f - deltaLat * mapScale) / 2.0f;
    }
    else {
      mapScale = 1.0f / deltaLat;
      mapTranslateY = 0;
      mapTranslateX = (1.0f - deltaLong * mapScale) / 2.0f;      
    }
  }
  
   public float longitudeToPageX(float longitude) {
    float relativeLong = longitude - minLongitude;
    return relativeLong * mapScale + mapTranslateX;
  }
  
   public float latitudeToPageY(float latitude) {
    float relativeLat = latitude - minLatitude;
    return 1.0f - (relativeLat * mapScale + mapTranslateY);
  }
  
   public float mapLengthToPageLength(float mapLen) {
    return mapLen * mapScale;
  }
  
   public float pageXtoLongitude(float pageX) {
    return (pageX - mapTranslateX) / mapScale + minLongitude;
  }
  
   public float pageYtoLatitude(float pageY) {
    return (1.0f - pageY - mapTranslateY) / mapScale + minLatitude;
  }
  
   public float pageLengthToMapLength(float pageLen) {
    return pageLen / mapScale;
  }
  
  
   public float longitudeToScreenX(float longitude) {
    float pageX = longitudeToPageX(longitude);
    return pageXtoScreenX(pageX);
  }
  
   public float latitudeToScreenY(float latitude) {
    float pageY = latitudeToPageY(latitude);
    return pageYtoScreenY(pageY);
  }
  
   public float mapLengthToScreenLength(float mapLen) {
    float pageLen = mapLengthToPageLength(mapLen);
    return pageLengthToScreenLength(pageLen); 
  }
  
  
   public float screenXtoLongitude(float screenX) {
    float pageX = screenXtoPageX(screenX);
    return pageXtoLongitude(pageX);
  }
  
   public float screenYtoLatitude(float screenY) {
    float pageY = screenYtoPageY(screenY);
    return pageYtoLatitude(pageY);
  }
  
   public float screenLengthToMapLength(float screenLen) {
    float pageLen = screenLengthToPageLength(screenLen);
    return pageLengthToMapLength(pageLen); 
  }
  
  float mapScale;
  float mapTranslateX;
  float mapTranslateY;
  
  float minLatitude;
  float maxLatitude;
  float minLongitude;
  float maxLongitude;
}
/* CSci-5609 Visualization Support Code  created by Prof. Dan Keefe, Fall 2023

This class is useful for creating 2D visualizations that are larger than the screen
and require panning and zooming with the mouse.  The way it works is that you draw
your visualization using the coordinate system of the PanZoomPage, and this class
keeps track of how that coordinate system relates to Processing's coordinate system.
The virtual page is always a square.  The origin (0,0) is at the top-left corner, like
Processing's coordinate system, but unlike Processing, the bottom-right corner of
the page has coordinates (1,1).  In other words, the virtual page is exactly 1 unit
wide by 1 unit tall.  This means anything you wish to draw within the page should have
floating point coordinates in the range 0.0 to 1.0.  In many ways this makes drawing
graphics a lot easier than Processing's default, which is 1 unit = 1 pixel.  To put
an object in the middle of the virtual page, you simply place it at (0.5, 0.5) -- no
need to check the width and height of the window and then divide by two as you would
with Processing's default coordinate system.  When the class is constructed, it
automatically sets an appropriate scale so that the virtual page fills the processing
window.  The class is quite lightweight.  It does not actually do any drawing for you.
It simply provides routines to convert from virtual page coordinates to Processing's
screen coordinates.  The way to use these is to define your graphics using virtual
page coordinates.  Then, right before drawing the graphics, use the conversion
functions to transform those virtual page coordinates into screen coordinates taking
into account the current zoom level and panning.

The code below provides a complete working example use of the class.  Click and drag
the left mouse button to pan the virtual page, and scroll the mouse wheel up or down
to zoom in and out.  

PanZoomPage panZoomPage;

void setup() {
  size(1600, 900);
  panZoomPage = new PanZoomPage(); 
}

void draw() {
  background(100);
  
  // draw a white square that covers the entire virtual page
  fill(255);
  stroke(0);
  rectMode(CORNERS);
  rect(panZoomPage.pageXtoScreenX(0), panZoomPage.pageYtoScreenY(0),
       panZoomPage.pageXtoScreenX(1), panZoomPage.pageYtoScreenY(1));

  // draw a circle at the center of the page with a radius 0.25 times the width
  // of the page
  float radius = panZoomPage.pageLengthToScreenLength(0.25);
  float cx = panZoomPage.pageXtoScreenX(0.5);
  float cy = panZoomPage.pageYtoScreenY(0.5);
  fill(200,0,200);
  ellipseMode(RADIUS);
  circle(cx, cy, radius);  
}

void mousePressed() {
  panZoomPage.mousePressed();
}

void mouseDragged() {
  panZoomPage.mouseDragged();
}

void mouseWheel(MouseEvent e) {
  panZoomPage.mouseWheel(e);
}
*/
public class PanZoomPage { 
  
  public PanZoomPage() {
    scale = 1.0f;
    translateX = 0.0f;
    translateY = 0.0f;
    lastMouseX = 0;
    lastMouseY = 0;
  
    fitPageOnScreen(); 
  }
  
  
   public float pageXtoScreenX(float pageX) {
    return pageX * scale + translateX; 
  }
  
   public float pageYtoScreenY(float pageY) {
    return pageY * scale + translateY; 
  }
  
   public float pageLengthToScreenLength(float l) {
    return l * scale; 
  }
  
  
   public float screenXtoPageX(float screenX) {
    return (screenX - translateX) / scale;
  }
  
   public float screenYtoPageY(float screenY) {
    return (screenY - translateY) / scale;
  }
  
   public float screenLengthToPageLength(float l) {
    return l / scale; 
  }
  
   public void fitPageOnScreen() {
    if (width >= height) {
      scale = height;
      translateY = 0;
      translateX = (width - height) / 2.0f;
    }
    else {
      scale = width;
      translateX = 0;
      translateY = (height - width) / 2.0f;
    }
  }

   public void mousePressed() {
    if (mouseButton == LEFT) {
      lastMouseX = mouseX;
      lastMouseY = mouseY;
    }
  }
  
   public void mouseDragged() {
    if (mouseButton == LEFT) {
      int deltaX = mouseX - lastMouseX;
      int deltaY = mouseY - lastMouseY;
      translateX += deltaX;
      translateY += deltaY;
      lastMouseX = mouseX;
      lastMouseY = mouseY;
    }
  }

   public void mouseWheel(MouseEvent e)
  {
    float scaleDelta = 1.0f;
    if (e.getCount() > 0) {
      scaleDelta = 1.3f;
    } 
    else if (e.getCount() < 0) {
      scaleDelta = 0.7f;
    }
  
    if (scaleDelta != 1.0f) {
      translateX -= mouseX;
      translateY -= mouseY;
      scale *= scaleDelta;
      translateX *= scaleDelta;
      translateY *= scaleDelta;
      translateX += mouseX;
      translateY += mouseY;
    }
  }
  
  float scale = 1.0f;
  float translateX = 0.0f;
  float translateY = 0.0f;
  int lastMouseX = 0;
  int lastMouseY = 0;
}
/* CSci-5609 Visualization Support Code  created by Prof. Dan Keefe, Fall 2023

To size or color graphics based on data, we need to know min and max ranges for the data.
These utilities help to quickly calculate mins and maxes for data organized in tables.
*/
static class TableUtils {
  
   public static float findMinFloatInColumn(Table t, int column) {
    float[] values = t.getFloatColumn(column);
    float min = values[0];
    for (int i=0; i<values.length; i++) {
      if (values[i] < min) {
        min = values[i]; 
      }
    }
    return min;
  }

   public static float findMinFloatInColumn(Table t, String columnName) {
    return findMinFloatInColumn(t, t.getColumnIndex(columnName));
  }
  
   public static float findMaxFloatInColumn(Table t, int column) {
    float[] values = t.getFloatColumn(column);
    float max = values[0];
    for (int i=0; i<values.length; i++) {
      if (values[i] > max) {
        max = values[i]; 
      }
    }
    return max;
  }

   public static float findMaxFloatInColumn(Table t, String columnName) {
    return findMaxFloatInColumn(t, t.getColumnIndex(columnName));
  }

  
}


  public void settings() { size(1600, 900); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Paafu1" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
